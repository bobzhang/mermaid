///|
test "Parser parity gate cases" {
  for case_data in gate_cases() {
    let graph = @parser_header_core.parse_mermaid(case_data.input)
    assert_eq(direction_name(graph.direction), case_data.direction)
    assert_eq(graph.nodes.length(), case_data.expected_node_count)
    assert_eq(graph.edges.length(), case_data.expected_edge_count)
  }
}

///|
test "Parser rejects unsupported header" {
  let result : Result[@model.MermaidGraph, @model.MermaidError] = try? @parser_header_core.parse_mermaid(
    (
      #|pie
      #|A : 1
    ),
  )
  assert_true(result is Err(_))
}

///|
test "Parser rejects empty input" {
  let result : Result[@model.MermaidGraph, @model.MermaidError] = try? @parser_header_core.parse_mermaid(
    "",
  )
  assert_true(result is Err(_))
}

///|
test "Parser ignores leading yaml frontmatter" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|---
      #|title: Flowchart internals
      #|references:
      #|  - /packages/mermaid/src/diagrams/flowchart/flowDiagram.ts
      #|generationTime: 2025-07-23T10:31:53.266Z
      #|---
      #|graph TD
      #|A --> B
    ),
  )
  assert_eq(direction_name(graph.direction), "TD")
  assert_eq(graph.edges.length(), 1)
}

///|
test "Parser ignores comments before yaml frontmatter" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|%% generated by docs tooling
      #|---
      #|title: Flowchart internals
      #|references:
      #|  - /packages/mermaid/src/diagrams/flowchart/flowDiagram.ts
      #|---
      #|flowchart LR
      #|A --> B
    ),
  )
  assert_eq(direction_name(graph.direction), "LR")
  assert_eq(graph.edges.length(), 1)
}

///|
test "Parser accepts all supported flowchart directions" {
  for direction in ["TD", "TB", "LR", "BT", "RL"] {
    let graph = @parser_header_core.parse_mermaid(
      (
        $|graph \{direction}
        $|A --> B
        $|
      )
      .trim_end()
      .to_string(),
    )
    assert_eq(direction_name(graph.direction), direction)
    assert_eq(graph.edges.length(), 1)
  }
}

///|
test "Parser accepts graph/flowchart headers without direction" {
  let graph_default = @parser_header_core.parse_mermaid(
    (
      #|graph
      #|A --> B
    ),
  )
  assert_eq(direction_name(graph_default.direction), "TD")
  assert_eq(graph_default.edges.length(), 1)

  let flowchart_default = @parser_header_core.parse_mermaid(
    (
      #|flowchart
      #|A --> B
    ),
  )
  assert_eq(direction_name(flowchart_default.direction), "TD")
  assert_eq(flowchart_default.edges.length(), 1)
}

///|
test "Parser rejects flowchart header with invalid direction token" {
  let result : Result[@model.MermaidGraph, @model.MermaidError] = try? @parser_header_core.parse_mermaid(
    (
      #|graph XX
      #|A --> B
    ),
  )
  assert_true(result is Err(_))
}

///|
test "Parser keeps first node definition for shape and label" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A[Start]
      #|A{Decision}
      #|A --> B
    ),
  )
  guard graph.nodes.get("A") is Some(node_a) else { fail("missing node A") }
  assert_eq(node_a.label, "Start")
  assert_eq(node_shape_name(node_a.shape), "Rectangle")
}

///|
test "Parser supports hyphenated node IDs" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|start-node --> end-node
    ),
  )

  assert_true(graph.nodes.get("start-node") is Some(_))
  assert_true(graph.nodes.get("end-node") is Some(_))
  assert_eq(graph.edges.length(), 1)
  assert_eq(graph.edges[0].source, "start-node")
  assert_eq(graph.edges[0].target, "end-node")
}

///|
test "Parser creates default rectangle nodes for bare references" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A --> B
    ),
  )

  guard graph.nodes.get("A") is Some(node_a) else { fail("missing node A") }
  assert_eq(node_shape_name(node_a.shape), "Rectangle")
  assert_eq(node_a.label, "A")
  guard graph.nodes.get("B") is Some(node_b) else { fail("missing node B") }
  assert_eq(node_shape_name(node_b.shape), "Rectangle")
  assert_eq(node_b.label, "B")
}

///|
test "Parser recognizes all flowchart node shape variants together" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A[Rectangle]
      #|B(Rounded)
      #|C{Diamond}
      #|D([Stadium])
      #|E((Circle))
      #|F[[Subroutine]]
      #|G(((DoubleCircle)))
      #|H{{Hexagon}}
      #|I[(Cylinder)]
      #|J>Asymmetric]
      #|K[/Trapezoid\\]
      #|L[\\TrapAlt/]
    ),
  )

  guard graph.nodes.get("A") is Some(node_a) else { fail("missing node A") }
  assert_eq(node_shape_name(node_a.shape), "Rectangle")
  guard graph.nodes.get("B") is Some(node_b) else { fail("missing node B") }
  assert_eq(node_shape_name(node_b.shape), "Rounded")
  guard graph.nodes.get("C") is Some(node_c) else { fail("missing node C") }
  assert_eq(node_shape_name(node_c.shape), "Diamond")
  guard graph.nodes.get("D") is Some(node_d) else { fail("missing node D") }
  assert_eq(node_shape_name(node_d.shape), "Stadium")
  guard graph.nodes.get("E") is Some(node_e) else { fail("missing node E") }
  assert_eq(node_shape_name(node_e.shape), "Circle")
  guard graph.nodes.get("F") is Some(node_f) else { fail("missing node F") }
  assert_eq(node_shape_name(node_f.shape), "Subroutine")
  guard graph.nodes.get("G") is Some(node_g) else { fail("missing node G") }
  assert_eq(node_shape_name(node_g.shape), "DoubleCircle")
  guard graph.nodes.get("H") is Some(node_h) else { fail("missing node H") }
  assert_eq(node_shape_name(node_h.shape), "Hexagon")
  guard graph.nodes.get("I") is Some(node_i) else { fail("missing node I") }
  assert_eq(node_shape_name(node_i.shape), "Cylinder")
  guard graph.nodes.get("J") is Some(node_j) else { fail("missing node J") }
  assert_eq(node_shape_name(node_j.shape), "Asymmetric")
  guard graph.nodes.get("K") is Some(node_k) else { fail("missing node K") }
  assert_eq(node_shape_name(node_k.shape), "Trapezoid")
  guard graph.nodes.get("L") is Some(node_l) else { fail("missing node L") }
  assert_eq(node_shape_name(node_l.shape), "TrapezoidAlt")
}

///|
test "Parser accepts case-insensitive flowchart header keywords" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|Graph td
      #|A --> B
    ),
  )
  assert_eq(direction_name(graph.direction), "TD")
  assert_eq(graph.edges.length(), 1)

  let flowchart = @parser_header_core.parse_mermaid(
    (
      #|FLOWCHART lr
      #|X --> Y
    ),
  )
  assert_eq(direction_name(flowchart.direction), "LR")
  assert_eq(flowchart.edges.length(), 1)
}

///|
test "Parser accepts tab-separated flowchart header tokens" {
  let graph = @parser_header_core.parse_mermaid("graph\tTD\nA --> B")
  assert_eq(direction_name(graph.direction), "TD")
  assert_eq(graph.edges.length(), 1)
}

///|
test "Parser preserves node definition order in map iteration" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|C
      #|A
      #|B
    ),
  )
  let ids = graph.nodes.to_array().map(entry => entry.0)

  assert_eq(ids.length(), 3)
  assert_eq(ids[0], "C")
  assert_eq(ids[1], "A")
  assert_eq(ids[2], "B")
}

///|
test "Parser parses no-arrow edge with label" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A ---|text| B
    ),
  )
  assert_eq(graph.edges.length(), 1)
  let edge = graph.edges[0]
  assert_eq(edge.source, "A")
  assert_eq(edge.target, "B")
  assert_eq(edge.label, Some("text"))
  assert_eq(edge_style_name(edge.style), "Solid")
  assert_true(!edge.has_arrow_start)
  assert_true(!edge.has_arrow_end)
}

///|
test "Parser keeps no-arrow operators without arrowheads across styles" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A --- B
      #|B -.- C
      #|C === D
    ),
  )
  assert_eq(graph.edges.length(), 3)

  let e1 = graph.edges[0]
  assert_eq(edge_style_name(e1.style), "Solid")
  assert_true(!e1.has_arrow_start)
  assert_true(!e1.has_arrow_end)

  let e2 = graph.edges[1]
  assert_eq(edge_style_name(e2.style), "Dotted")
  assert_true(!e2.has_arrow_start)
  assert_true(!e2.has_arrow_end)

  let e3 = graph.edges[2]
  assert_eq(edge_style_name(e3.style), "Thick")
  assert_true(!e3.has_arrow_start)
  assert_true(!e3.has_arrow_end)
}

///|
test "Parser parses dotted bidirectional edge operator" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A <-.-> B
    ),
  )
  assert_eq(graph.edges.length(), 1)
  let edge = graph.edges[0]
  assert_eq(edge_style_name(edge.style), "Dotted")
  assert_true(edge.has_arrow_start)
  assert_true(edge.has_arrow_end)
}

///|
test "Parser parses solid bidirectional edge operator" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A <--> B
    ),
  )
  assert_eq(graph.edges.length(), 1)
  let edge = graph.edges[0]
  assert_eq(edge_style_name(edge.style), "Solid")
  assert_true(edge.has_arrow_start)
  assert_true(edge.has_arrow_end)
}

///|
test "Parser keeps edge styles and labels for solid dotted and thick links" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A -->|solid| B
      #|B -.->|dotted| C
      #|C ==>|thick| D
    ),
  )
  assert_eq(graph.edges.length(), 3)

  let e1 = graph.edges[0]
  assert_eq(edge_style_name(e1.style), "Solid")
  assert_eq(e1.label, Some("solid"))

  let e2 = graph.edges[1]
  assert_eq(edge_style_name(e2.style), "Dotted")
  assert_eq(e2.label, Some("dotted"))

  let e3 = graph.edges[2]
  assert_eq(edge_style_name(e3.style), "Thick")
  assert_eq(e3.label, Some("thick"))
}

///|
test "Parser expands chained edges in order" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A --> B --> C
    ),
  )
  assert_eq(graph.edges.length(), 2)
  assert_eq(graph.edges[0].source, "A")
  assert_eq(graph.edges[0].target, "B")
  assert_eq(graph.edges[1].source, "B")
  assert_eq(graph.edges[1].target, "C")
}

///|
test "Parser handles multiple edge lines" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A --> B
      #|B --> C
      #|C --> D
    ),
  )
  assert_eq(graph.edges.length(), 3)
  assert_eq(graph.edges[0].source, "A")
  assert_eq(graph.edges[2].target, "D")
}

///|
test "Parser expands chained edges while preserving inline shapes" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A[Start] --> B{Check} --> C(End)
    ),
  )
  assert_eq(graph.edges.length(), 2)

  guard graph.nodes.get("A") is Some(node_a) else { fail("missing node A") }
  assert_eq(node_shape_name(node_a.shape), "Rectangle")
  guard graph.nodes.get("B") is Some(node_b) else { fail("missing node B") }
  assert_eq(node_shape_name(node_b.shape), "Diamond")
  guard graph.nodes.get("C") is Some(node_c) else { fail("missing node C") }
  assert_eq(node_shape_name(node_c.shape), "Rounded")
}

///|
test "Parser keeps ampersand inside node labels while still expanding parallel links" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A[Input] & B[Config] --> C[Processor]
      #|B --> D[Fix & Retry]
    ),
  )

  assert_eq(graph.nodes.length(), 4)
  assert_eq(graph.edges.length(), 3)

  guard graph.nodes.get("D") is Some(node_d) else { fail("missing node D") }
  assert_eq(node_d.id, "D")
  assert_eq(node_d.label, "Fix & Retry")
}

///|
test "Parser handles extra whitespace and empty lines" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|  graph   TD  
      #|
      #|  A   -->   B  
      #|
      #|  B -->   C  
      #|
    )
    .trim_end()
    .to_string(),
  )
  assert_eq(direction_name(graph.direction), "TD")
  assert_eq(graph.nodes.length(), 3)
  assert_eq(graph.edges.length(), 2)
}

///|
test "Parser handles diagram with only standalone nodes" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A
      #|B[Beta]
      #|C{Choice}
    ),
  )
  assert_eq(graph.edges.length(), 0)
  assert_true(graph.nodes.get("A") is Some(_))
  assert_true(graph.nodes.get("B") is Some(_))
  assert_true(graph.nodes.get("C") is Some(_))
}

///|
test "Parser rejects flowchart header with extra trailing tokens" {
  let result : Result[@model.MermaidGraph, @model.MermaidError] = try? @parser_header_core.parse_mermaid(
    (
      #|graph TD extra
      #|A --> B
    ),
  )
  assert_true(result is Err(_))
}

///|
test "Parser ignores comment lines including indented comments" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|%% comment
      #|  %% another comment
      #|A --> B
    ),
  )
  assert_eq(graph.nodes.length(), 2)
  assert_eq(graph.edges.length(), 1)
  assert_eq(graph.edges[0].source, "A")
  assert_eq(graph.edges[0].target, "B")
}

///|
test "Parser rejects stateDiagram header with extra trailing tokens" {
  let result : Result[@model.MermaidGraph, @model.MermaidError] = try? @parser_header_core.parse_mermaid(
    (
      #|stateDiagram-v2 extra
      #|A --> B
    ),
  )
  assert_true(result is Err(_))
}

///|
test "Full corpus inventory is imported" {
  let all = corpus_cases()
  assert_eq(all.length(), 60)
  let supported = all.filter(case_data => case_data.supported_by_moonbit)
  assert_eq(supported.length(), 60)
}

///|
test "Parser parses thick bidirectional edge operator" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A <==> B
    ),
  )
  assert_eq(graph.edges.length(), 1)
  let edge = graph.edges[0]
  assert_eq(edge_style_name(edge.style), "Thick")
  assert_true(edge.has_arrow_start)
  assert_true(edge.has_arrow_end)
}

///|
test "Parser expands mixed chained operators with correct precedence" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A --- B --> C -.-> D === E
    ),
  )
  assert_eq(graph.edges.length(), 4)

  let e1 = graph.edges[0]
  assert_eq(e1.source, "A")
  assert_eq(e1.target, "B")
  assert_eq(edge_style_name(e1.style), "Solid")
  assert_true(!e1.has_arrow_start)
  assert_true(!e1.has_arrow_end)

  let e2 = graph.edges[1]
  assert_eq(e2.source, "B")
  assert_eq(e2.target, "C")
  assert_eq(edge_style_name(e2.style), "Solid")
  assert_true(!e2.has_arrow_start)
  assert_true(e2.has_arrow_end)

  let e3 = graph.edges[2]
  assert_eq(e3.source, "C")
  assert_eq(e3.target, "D")
  assert_eq(edge_style_name(e3.style), "Dotted")
  assert_true(!e3.has_arrow_start)
  assert_true(e3.has_arrow_end)

  let e4 = graph.edges[3]
  assert_eq(e4.source, "D")
  assert_eq(e4.target, "E")
  assert_eq(edge_style_name(e4.style), "Thick")
  assert_true(!e4.has_arrow_start)
  assert_true(!e4.has_arrow_end)
}
