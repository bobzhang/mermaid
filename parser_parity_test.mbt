///|
test "Parser parity gate cases" {
  for case_data in gate_cases() {
    let graph = @parser_header_core.parse_mermaid(case_data.input)
    assert_eq(graph.direction.to_string(), case_data.direction)
    assert_eq(graph.nodes.length(), case_data.expected_node_count)
    assert_eq(graph.edges.length(), case_data.expected_edge_count)
  }
}

///|
test "Parser rejects unsupported header" {
  let result : Result[@model.MermaidGraph, @beautiful_mermaid.MermaidError] = try? @parser_header_core.parse_mermaid(
    (
      #|pie
      #|A : 1
    ),
  )
  assert_true(result is Err(_))
}

///|
test "Parser rejects empty input" {
  let result : Result[@model.MermaidGraph, @beautiful_mermaid.MermaidError] = try? @parser_header_core.parse_mermaid(
    "",
  )
  assert_true(result is Err(_))
}

///|
test "Parser ignores leading yaml frontmatter" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|---
      #|title: Flowchart internals
      #|references:
      #|  - /packages/mermaid/src/diagrams/flowchart/flowDiagram.ts
      #|generationTime: 2025-07-23T10:31:53.266Z
      #|---
      #|graph TD
      #|A --> B
    ),
  )
  assert_eq(graph.direction.to_string(), "TD")
  assert_eq(graph.edges.length(), 1)
}

///|
test "Parser ignores comments before yaml frontmatter" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|%% generated by docs tooling
      #|---
      #|title: Flowchart internals
      #|references:
      #|  - /packages/mermaid/src/diagrams/flowchart/flowDiagram.ts
      #|---
      #|flowchart LR
      #|A --> B
    ),
  )
  assert_eq(graph.direction.to_string(), "LR")
  assert_eq(graph.edges.length(), 1)
}

///|
test "Parser accepts all supported flowchart directions" {
  for direction in ["TD", "TB", "LR", "BT", "RL"] {
    let graph = @parser_header_core.parse_mermaid(
      (
        $|graph \{direction}
        $|A --> B
        $|
      )
      .trim_end()
      .to_string(),
    )
    assert_eq(graph.direction.to_string(), direction)
    assert_eq(graph.edges.length(), 1)
  }
}

///|
test "Parser accepts graph/flowchart headers without direction" {
  let graph_default = @parser_header_core.parse_mermaid(
    (
      #|graph
      #|A --> B
    ),
  )
  assert_eq(graph_default.direction.to_string(), "TD")
  assert_eq(graph_default.edges.length(), 1)

  let flowchart_default = @parser_header_core.parse_mermaid(
    (
      #|flowchart
      #|A --> B
    ),
  )
  assert_eq(flowchart_default.direction.to_string(), "TD")
  assert_eq(flowchart_default.edges.length(), 1)
}

///|
test "Parser rejects flowchart header with invalid direction token" {
  let result : Result[@model.MermaidGraph, @beautiful_mermaid.MermaidError] = try? @parser_header_core.parse_mermaid(
    (
      #|graph XX
      #|A --> B
    ),
  )
  assert_true(result is Err(_))
}

///|
test "Parser keeps first node definition for shape and label" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A[Start]
      #|A{Decision}
      #|A --> B
    ),
  )
  match graph.nodes.get("A") {
    Some(node) => {
      assert_eq(node.label, "Start")
      assert_eq(node.shape.to_string(), "Rectangle")
    }
    None => fail("missing node A")
  }
}

///|
test "Parser supports hyphenated node IDs" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|start-node --> end-node
    ),
  )

  assert_true(graph.nodes.get("start-node") is Some(_))
  assert_true(graph.nodes.get("end-node") is Some(_))
  assert_eq(graph.edges.length(), 1)
  assert_eq(graph.edges[0].source, "start-node")
  assert_eq(graph.edges[0].target, "end-node")
}

///|
test "Parser creates default rectangle nodes for bare references" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A --> B
    ),
  )

  match graph.nodes.get("A") {
    Some(node) => {
      assert_eq(node.shape.to_string(), "Rectangle")
      assert_eq(node.label, "A")
    }
    None => fail("missing node A")
  }
  match graph.nodes.get("B") {
    Some(node) => {
      assert_eq(node.shape.to_string(), "Rectangle")
      assert_eq(node.label, "B")
    }
    None => fail("missing node B")
  }
}

///|
test "Parser recognizes all flowchart node shape variants together" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A[Rectangle]
      #|B(Rounded)
      #|C{Diamond}
      #|D([Stadium])
      #|E((Circle))
      #|F[[Subroutine]]
      #|G(((DoubleCircle)))
      #|H{{Hexagon}}
      #|I[(Cylinder)]
      #|J>Asymmetric]
      #|K[/Trapezoid\\]
      #|L[\\TrapAlt/]
    ),
  )

  match graph.nodes.get("A") {
    Some(node) => assert_eq(node.shape.to_string(), "Rectangle")
    None => fail("missing node A")
  }
  match graph.nodes.get("B") {
    Some(node) => assert_eq(node.shape.to_string(), "Rounded")
    None => fail("missing node B")
  }
  match graph.nodes.get("C") {
    Some(node) => assert_eq(node.shape.to_string(), "Diamond")
    None => fail("missing node C")
  }
  match graph.nodes.get("D") {
    Some(node) => assert_eq(node.shape.to_string(), "Stadium")
    None => fail("missing node D")
  }
  match graph.nodes.get("E") {
    Some(node) => assert_eq(node.shape.to_string(), "Circle")
    None => fail("missing node E")
  }
  match graph.nodes.get("F") {
    Some(node) => assert_eq(node.shape.to_string(), "Subroutine")
    None => fail("missing node F")
  }
  match graph.nodes.get("G") {
    Some(node) => assert_eq(node.shape.to_string(), "DoubleCircle")
    None => fail("missing node G")
  }
  match graph.nodes.get("H") {
    Some(node) => assert_eq(node.shape.to_string(), "Hexagon")
    None => fail("missing node H")
  }
  match graph.nodes.get("I") {
    Some(node) => assert_eq(node.shape.to_string(), "Cylinder")
    None => fail("missing node I")
  }
  match graph.nodes.get("J") {
    Some(node) => assert_eq(node.shape.to_string(), "Asymmetric")
    None => fail("missing node J")
  }
  match graph.nodes.get("K") {
    Some(node) => assert_eq(node.shape.to_string(), "Trapezoid")
    None => fail("missing node K")
  }
  match graph.nodes.get("L") {
    Some(node) => assert_eq(node.shape.to_string(), "TrapezoidAlt")
    None => fail("missing node L")
  }
}

///|
test "Parser accepts case-insensitive flowchart header keywords" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|Graph td
      #|A --> B
    ),
  )
  assert_eq(graph.direction.to_string(), "TD")
  assert_eq(graph.edges.length(), 1)

  let flowchart = @parser_header_core.parse_mermaid(
    (
      #|FLOWCHART lr
      #|X --> Y
    ),
  )
  assert_eq(flowchart.direction.to_string(), "LR")
  assert_eq(flowchart.edges.length(), 1)
}

///|
test "Parser accepts tab-separated flowchart header tokens" {
  let graph = @parser_header_core.parse_mermaid("graph\tTD\nA --> B")
  assert_eq(graph.direction.to_string(), "TD")
  assert_eq(graph.edges.length(), 1)
}

///|
test "Parser preserves node definition order in map iteration" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|C
      #|A
      #|B
    ),
  )
  let ids = graph.nodes.to_array().map(entry => entry.0)

  assert_eq(ids.length(), 3)
  assert_eq(ids[0], "C")
  assert_eq(ids[1], "A")
  assert_eq(ids[2], "B")
}

///|
test "Parser parses no-arrow edge with label" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A ---|text| B
    ),
  )
  assert_eq(graph.edges.length(), 1)
  let edge = graph.edges[0]
  assert_eq(edge.source, "A")
  assert_eq(edge.target, "B")
  assert_eq(edge.label, Some("text"))
  assert_eq(edge.style.to_string(), "Solid")
  assert_true(!edge.has_arrow_start)
  assert_true(!edge.has_arrow_end)
}

///|
test "Parser keeps no-arrow operators without arrowheads across styles" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A --- B
      #|B -.- C
      #|C === D
    ),
  )
  assert_eq(graph.edges.length(), 3)

  let e1 = graph.edges[0]
  assert_eq(e1.style.to_string(), "Solid")
  assert_true(!e1.has_arrow_start)
  assert_true(!e1.has_arrow_end)

  let e2 = graph.edges[1]
  assert_eq(e2.style.to_string(), "Dotted")
  assert_true(!e2.has_arrow_start)
  assert_true(!e2.has_arrow_end)

  let e3 = graph.edges[2]
  assert_eq(e3.style.to_string(), "Thick")
  assert_true(!e3.has_arrow_start)
  assert_true(!e3.has_arrow_end)
}

///|
test "Parser parses dotted bidirectional edge operator" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A <-.-> B
    ),
  )
  assert_eq(graph.edges.length(), 1)
  let edge = graph.edges[0]
  assert_eq(edge.style.to_string(), "Dotted")
  assert_true(edge.has_arrow_start)
  assert_true(edge.has_arrow_end)
}

///|
test "Parser parses solid bidirectional edge operator" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A <--> B
    ),
  )
  assert_eq(graph.edges.length(), 1)
  let edge = graph.edges[0]
  assert_eq(edge.style.to_string(), "Solid")
  assert_true(edge.has_arrow_start)
  assert_true(edge.has_arrow_end)
}

///|
test "Parser keeps edge styles and labels for solid dotted and thick links" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A -->|solid| B
      #|B -.->|dotted| C
      #|C ==>|thick| D
    ),
  )
  assert_eq(graph.edges.length(), 3)

  let e1 = graph.edges[0]
  assert_eq(e1.style.to_string(), "Solid")
  assert_eq(e1.label, Some("solid"))

  let e2 = graph.edges[1]
  assert_eq(e2.style.to_string(), "Dotted")
  assert_eq(e2.label, Some("dotted"))

  let e3 = graph.edges[2]
  assert_eq(e3.style.to_string(), "Thick")
  assert_eq(e3.label, Some("thick"))
}

///|
test "Parser expands chained edges in order" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A --> B --> C
    ),
  )
  assert_eq(graph.edges.length(), 2)
  assert_eq(graph.edges[0].source, "A")
  assert_eq(graph.edges[0].target, "B")
  assert_eq(graph.edges[1].source, "B")
  assert_eq(graph.edges[1].target, "C")
}

///|
test "Parser handles multiple edge lines" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A --> B
      #|B --> C
      #|C --> D
    ),
  )
  assert_eq(graph.edges.length(), 3)
  assert_eq(graph.edges[0].source, "A")
  assert_eq(graph.edges[2].target, "D")
}

///|
test "Parser expands chained edges while preserving inline shapes" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A[Start] --> B{Check} --> C(End)
    ),
  )
  assert_eq(graph.edges.length(), 2)

  match graph.nodes.get("A") {
    Some(node) => assert_eq(node.shape.to_string(), "Rectangle")
    None => fail("missing node A")
  }
  match graph.nodes.get("B") {
    Some(node) => assert_eq(node.shape.to_string(), "Diamond")
    None => fail("missing node B")
  }
  match graph.nodes.get("C") {
    Some(node) => assert_eq(node.shape.to_string(), "Rounded")
    None => fail("missing node C")
  }
}

///|
test "Parser keeps ampersand inside node labels while still expanding parallel links" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A[Input] & B[Config] --> C[Processor]
      #|B --> D[Fix & Retry]
    ),
  )

  assert_eq(graph.nodes.length(), 4)
  assert_eq(graph.edges.length(), 3)

  match graph.nodes.get("D") {
    Some(node) => {
      assert_eq(node.id, "D")
      assert_eq(node.label, "Fix & Retry")
    }
    None => fail("missing node D")
  }
}

///|
test "Parser handles extra whitespace and empty lines" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|  graph   TD  
      #|
      #|  A   -->   B  
      #|
      #|  B -->   C  
      #|
    )
    .trim_end()
    .to_string(),
  )
  assert_eq(graph.direction.to_string(), "TD")
  assert_eq(graph.nodes.length(), 3)
  assert_eq(graph.edges.length(), 2)
}

///|
test "Parser handles diagram with only standalone nodes" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A
      #|B[Beta]
      #|C{Choice}
    ),
  )
  assert_eq(graph.edges.length(), 0)
  assert_true(graph.nodes.get("A") is Some(_))
  assert_true(graph.nodes.get("B") is Some(_))
  assert_true(graph.nodes.get("C") is Some(_))
}

///|
test "Parser rejects flowchart header with extra trailing tokens" {
  let result : Result[@model.MermaidGraph, @beautiful_mermaid.MermaidError] = try? @parser_header_core.parse_mermaid(
    (
      #|graph TD extra
      #|A --> B
    ),
  )
  assert_true(result is Err(_))
}

///|
test "Parser ignores comment lines including indented comments" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|%% comment
      #|  %% another comment
      #|A --> B
    ),
  )
  assert_eq(graph.nodes.length(), 2)
  assert_eq(graph.edges.length(), 1)
  assert_eq(graph.edges[0].source, "A")
  assert_eq(graph.edges[0].target, "B")
}

///|
test "Parser rejects stateDiagram header with extra trailing tokens" {
  let result : Result[@model.MermaidGraph, @beautiful_mermaid.MermaidError] = try? @parser_header_core.parse_mermaid(
    (
      #|stateDiagram-v2 extra
      #|A --> B
    ),
  )
  assert_true(result is Err(_))
}

///|
test "Full corpus inventory is imported" {
  let all = corpus_cases()
  assert_eq(all.length(), 60)
  let supported = all.filter(case_data => case_data.supported_by_moonbit)
  assert_eq(supported.length(), 60)
}

///|
test "Parser parses thick bidirectional edge operator" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A <==> B
    ),
  )
  assert_eq(graph.edges.length(), 1)
  let edge = graph.edges[0]
  assert_eq(edge.style.to_string(), "Thick")
  assert_true(edge.has_arrow_start)
  assert_true(edge.has_arrow_end)
}

///|
test "Parser expands mixed chained operators with correct precedence" {
  let graph = @parser_header_core.parse_mermaid(
    (
      #|graph TD
      #|A --- B --> C -.-> D === E
    ),
  )
  assert_eq(graph.edges.length(), 4)

  let e1 = graph.edges[0]
  assert_eq(e1.source, "A")
  assert_eq(e1.target, "B")
  assert_eq(e1.style.to_string(), "Solid")
  assert_true(!e1.has_arrow_start)
  assert_true(!e1.has_arrow_end)

  let e2 = graph.edges[1]
  assert_eq(e2.source, "B")
  assert_eq(e2.target, "C")
  assert_eq(e2.style.to_string(), "Solid")
  assert_true(!e2.has_arrow_start)
  assert_true(e2.has_arrow_end)

  let e3 = graph.edges[2]
  assert_eq(e3.source, "C")
  assert_eq(e3.target, "D")
  assert_eq(e3.style.to_string(), "Dotted")
  assert_true(!e3.has_arrow_start)
  assert_true(e3.has_arrow_end)

  let e4 = graph.edges[3]
  assert_eq(e4.source, "D")
  assert_eq(e4.target, "E")
  assert_eq(e4.style.to_string(), "Thick")
  assert_true(!e4.has_arrow_start)
  assert_true(!e4.has_arrow_end)
}
